<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Solitario Art Deco</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Poppins:wght@300;400&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-black: #1a1a1a;
            --color-gold: #d4af37;
            --color-dark-gold: #b89b30;
            --color-cream: #f5f5dc;
            --color-dark-green: #013220;
            --color-red: #d92b2b;
            --card-width: 100px;
            --card-height: 140px;
            --border-radius: 8px;
            --gap: 15px;
            --card-offset: 38px;
        }

        body {
            background-color: var(--color-black);
            background-image:
                radial-gradient(farthest-side at 50% 100%, rgba(212, 175, 55, 0.12), transparent),
                radial-gradient(farthest-side at 50% 0, transparent, rgba(212, 175, 55, 0.12));
            background-size: 50px 50px;
            background-position: 0 0, 0 25px;
            color: var(--color-cream);
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden;
            min-width: 320px;
        }

        h1 {
            font-family: 'Cinzel', serif;
            color: var(--color-gold);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 3px;
            margin: 0;
            padding-bottom: 20px;
            font-size: 2.5rem;
            text-align: center;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--gap);
            margin-bottom: 20px;
            width: 100%;
            max-width: calc(7 * var(--card-width) + 6 * var(--gap));
            flex-wrap: wrap;
        }

        .art-deco-button, .timer {
            background: linear-gradient(145deg, var(--color-dark-gold), var(--color-gold));
            border: 2px solid var(--color-dark-gold);
            color: var(--color-black);
            padding: 10px 20px;
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            font-weight: bold;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5), inset 0 2px 2px rgba(255,255,255,0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
        }
        
        .art-deco-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.6), inset 0 2px 2px rgba(255,255,255,0.3);
        }
        
        .art-deco-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #555;
            color: #999;
            border-color: #444;
        }

        .timer {
            cursor: default;
            flex-grow: 1;
            text-align: center;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(7, var(--card-width));
            gap: var(--gap);
            background-color: var(--color-dark-green);
            padding: 20px;
            border-radius: var(--border-radius);
            border: 5px solid;
            border-image: linear-gradient(145deg, var(--color-gold), var(--color-dark-gold)) 1;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
            width: fit-content;
        }

        .top-area {
            grid-column: 1 / span 7;
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--gap);
        }

        .left-top, .right-top {
            display: flex;
            gap: var(--gap);
        }
        
        .slot {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: var(--border-radius);
            border: 2px dashed rgba(212, 175, 55, 0.4);
            position: relative;
        }
        
        .slot::before {
            font-family: 'Cinzel', serif;
            color: rgba(212, 175, 55, 0.3);
            font-size: 3rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .foundation.spades::before   { content: '♠'; }
        .foundation.hearts::before   { content: '♥'; }
        .foundation.clubs::before    { content: '♣'; }
        .foundation.diamonds::before { content: '♦'; }
        
        .tableau {
            position: relative;
        }
        
        .card {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: var(--border-radius);
            position: absolute;
            cursor: grab;
            user-select: none;
            transition: top 0.3s ease, left 0.3s ease, transform 0.5s ease;
            transform-style: preserve-3d;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        }
        
        .card.dragging {
            cursor: grabbing;
            z-index: 1000;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            transition: none;
        }
        
        .card.face-up.dragging {
            transform: rotateY(180deg) scale(1.03);
        }
        
        .card .card-face, .card .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: var(--border-radius);
        }

        .card .card-back {
            background-color: var(--color-black);
            background-image: 
                repeating-linear-gradient(45deg, var(--color-dark-gold) 0, var(--color-dark-gold) 10px, transparent 10px, transparent 20px),
                repeating-linear-gradient(-45deg, var(--color-dark-gold) 0, var(--color-dark-gold) 10px, transparent 10px, transparent 20px);
            border: 4px solid var(--color-gold);
            box-sizing: border-box;
            transform: rotateY(0deg);
        }

        .card .card-face {
            background-color: var(--color-cream);
            color: var(--color-black);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
            font-size: 1.5rem;
            font-weight: bold;
            transform: rotateY(180deg);
        }
        
        .card.face-up {
            transform: rotateY(180deg);
        }
        
        .card.red .card-face {
            color: var(--color-red);
        }

        .card-top, .card-bottom {
            width: 100%;
            display: flex;
            align-items: center;
            padding: 0 5px;
            line-height: 1;
        }
        .card-top {
            justify-content: flex-start;
        }
        .card-bottom {
            justify-content: flex-end;
            transform: rotate(180deg);
        }
        
        .card-suit {
            font-size: 1.1em; /* Restaurado a tamaño original para pantallas grandes */
            margin-left: 4px;
        }
        
        .card-middle-suit {
            font-size: clamp(1.2rem, 4vw, 2.8rem); /* Restaurado a tamaño original responsivo */
        }

        .bounce {
            animation: bounce-in 0.4s ease;
        }

        @keyframes bounce-in {
            0% { transform: scale(1) rotateY(180deg); }
            50% { transform: scale(1.15) rotateY(180deg); }
            100% { transform: scale(1) rotateY(180deg); }
        }

        #win-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            text-align: center;
        }
        
        #win-message.show {
            opacity: 1;
            visibility: visible;
        }

        #win-message h2 {
            font-family: 'Cinzel', serif;
            color: var(--color-gold);
            font-size: 4rem;
            text-shadow: 3px 3px 8px rgba(0,0,0,0.7);
            margin: 0;
        }
        
        #final-scores {
            background-color: rgba(1, 50, 32, 0.8);
            border: 2px solid var(--color-gold);
            border-radius: var(--border-radius);
            padding: 10px 30px;
            margin: 20px 0;
        }

        #final-scores p {
            font-size: 1.5rem;
            color: var(--color-cream);
            margin: 10px 0;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 26, 26, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--color-dark-green);
            border: 3px solid var(--color-gold);
            border-radius: var(--border-radius);
            padding: 30px;
            width: 90%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .loader-content {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(245, 245, 220, 0.3);
            border-top: 5px solid var(--color-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        footer {
            position: fixed;
            bottom: 15px;
            width: 100%;
            text-align: center;
            color: var(--color-gold);
            opacity: 0.4;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            pointer-events: none;
            user-select: none;
            letter-spacing: 2px;
        }

        /* --- Responsive Design --- */
        
        /* Medium screens (tablets) */
        @media (max-width: 900px) {
            :root {
                --card-width: 80px;
                --card-height: 112px;
                --gap: 12px;
                --card-offset: 30px;
            }
            .card-suit {
                font-size: 0.85em; /* Reducido 15% */
            }
            h1 {
                font-size: 2rem;
                padding-bottom: 15px;
            }
            .art-deco-button, .timer {
                font-size: 0.9rem;
                padding: 8px 16px;
            }
        }

        /* Small screens (smartphones) */
        @media (max-width: 600px) {
            :root {
                --gap: 8px;
                --card-width: calc((100vw - 8 * var(--gap)) / 7.5);
                --card-height: calc(var(--card-width) * 1.4);
                --card-offset: 25px;
            }
            body {
                padding: 10px;
            }
            h1 {
                font-size: 1.5rem;
                padding-bottom: 10px;
            }
            .game-controls {
                margin-bottom: 15px;
            }
            #game-board {
                padding: 10px;
            }
            .art-deco-button, .timer {
                font-size: 0.8rem;
                padding: 6px 12px;
                letter-spacing: 0.5px;
            }
            .card .card-face {
                font-size: 1.2rem;
            }
            .card-suit {
                font-size: 0.55em; /* Reducido 10% más para móviles */
            }
            .card-middle-suit {
                font-size: 0.68rem; /* Reducido 10% más para móviles */
            }
            .slot::before {
                font-size: 1rem; /* Reducido 50% para pantallas pequeñas */
            }
        }

    </style>
</head>
<body>

    <h1>Solitario Art Deco</h1>

    <div class="game-controls">
        <button id="new-game-btn" class="art-deco-button">Nueva Partida</button>
        <div id="timer" class="timer">Tiempo: 00:00</div>
        <div id="score" class="timer">Puntos: 0</div>
        <button id="undo-btn" class="art-deco-button" disabled>Deshacer</button>
        <button id="get-hint-btn" class="art-deco-button">✨ Pista</button>
    </div>

    <div id="game-board">
        <div class="top-area">
            <div class="left-top">
                <div id="stock" class="slot"></div>
                <div id="waste" class="slot"></div>
            </div>
            <div class="right-top">
                <div id="foundation-0" class="slot foundation spades"></div>
                <div id="foundation-1" class="slot foundation hearts"></div>
                <div id="foundation-2" class="slot foundation clubs"></div>
                <div id="foundation-3" class="slot foundation diamonds"></div>
            </div>
        </div>
        
        <div id="tableau-0" class="slot tableau"></div>
        <div id="tableau-1" class="slot tableau"></div>
        <div id="tableau-2" class="slot tableau"></div>
        <div id="tableau-3" class="slot tableau"></div>
        <div id="tableau-4" class="slot tableau"></div>
        <div id="tableau-5" class="slot tableau"></div>
        <div id="tableau-6" class="slot tableau"></div>
    </div>

    <div id="win-message">
        <h2>¡Victoria!</h2>
        <div id="final-scores">
            <p>Tu Puntuación: <span id="final-score">0</span></p>
            <p>Mejor Puntuación: <span id="high-score">0</span></p>
        </div>
        <button id="win-new-game-btn" class="art-deco-button">Jugar de Nuevo</button>
    </div>

    <div id="start-menu-overlay" class="modal-overlay">
        <div class="modal-content">
            <h3 style="font-size: 2.5rem; margin-bottom: 10px; font-family: 'Cinzel', serif; color: var(--color-gold);">Solitario Art Deco</h3>
            <p style="font-size: 1.1rem; color: var(--color-cream); margin-bottom: 30px;">Selecciona una dificultad:</p>
            <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                <button id="easy-mode-btn" class="art-deco-button">Fácil (Robar 1)</button>
                <button id="realistic-mode-btn" class="art-deco-button">Realista (Robar 3)</button>
            </div>
        </div>
    </div>

    <div id="hint-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Sugerencia del Experto</h3>
            <p id="hint-text"></p>
            <button id="close-hint-btn" class="art-deco-button">Cerrar</button>
        </div>
    </div>

    <div id="loader" class="modal-overlay">
        <div class="loader-content"></div>
    </div>

    <footer>Designed by SPHERE</footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const SUITS = ['spades', 'hearts', 'clubs', 'diamonds'];
            const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const SUIT_SYMBOLS = { spades: '♠', hearts: '♥', clubs: '♣', diamonds: '♦' };
            
            let stock = [], waste = [], foundations = [[], [], [], []], tableau = [[], [], [], [], [], [], []];
            let moveHistory = [];
            let timerInterval, seconds = 0;
            let drawCount = 1;
            let cardOffset = 38;
            let score = 0, highScore = 0;
            
            let dragState = {
                draggedCards: [],
                source: null,
                startMouseX: 0,
                startMouseY: 0,
                initialCardPositions: []
            };

            const newGameBtn = document.getElementById('new-game-btn');
            const winNewGameBtn = document.getElementById('win-new-game-btn');
            const undoBtn = document.getElementById('undo-btn');
            const timerEl = document.getElementById('timer');
            const scoreEl = document.getElementById('score');
            const winMessageEl = document.getElementById('win-message');
            const stockEl = document.getElementById('stock');
            const wasteEl = document.getElementById('waste');
            const foundationEls = Array.from({ length: 4 }, (_, i) => document.getElementById(`foundation-${i}`));
            const tableauEls = Array.from({ length: 7 }, (_, i) => document.getElementById(`tableau-${i}`));
            const getHintBtn = document.getElementById('get-hint-btn');
            const hintModal = document.getElementById('hint-modal');
            const hintText = document.getElementById('hint-text');
            const closeHintBtn = document.getElementById('close-hint-btn');
            const loader = document.getElementById('loader');
            const startMenuOverlay = document.getElementById('start-menu-overlay');
            const easyModeBtn = document.getElementById('easy-mode-btn');
            const realisticModeBtn = document.getElementById('realistic-mode-btn');
            
            function updateLayoutValues() {
                const newOffset = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-offset'));
                if (!isNaN(newOffset)) {
                    cardOffset = newOffset;
                }
            }
            
            function startGame(selectedDrawCount) {
                drawCount = selectedDrawCount;
                startMenuOverlay.classList.remove('show');

                stock = [], waste = [], foundations = [[], [], [], []], tableau = [[], [], [], [], [], [], []];
                moveHistory = [];
                document.querySelectorAll('.card').forEach(card => card.remove());
                undoBtn.disabled = true;
                winMessageEl.classList.remove('show');
                
                score = 0;
                updateScore(0);

                startTimer();
                createDeck();
                shuffleDeck();
                dealCards();
                renderAllPiles();
            }

            function initGame() {
                clearInterval(timerInterval);
                timerEl.textContent = 'Tiempo: 00:00';
                highScore = parseInt(localStorage.getItem('solitaireHighScore')) || 0;
                score = 0;
                updateScore(0);
                stock = [], waste = [], foundations = [[], [], [], []], tableau = [[], [], [], [], [], [], []];
                renderAllPiles();
                startMenuOverlay.classList.add('show');
            }

            function updateScore(points) {
                score += points;
                if (score < 0) score = 0; // Score cannot be negative
                scoreEl.textContent = `Puntos: ${score}`;
            }

            function createDeck() {
                stock = [];
                for (const suit of SUITS) {
                    for (let i = 0; i < RANKS.length; i++) {
                        stock.push({ suit, rank: RANKS[i], value: i + 1, color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black', faceUp: false, id: `${RANKS[i]}-${suit}` });
                    }
                }
            }
            
            function shuffleDeck() {
                for (let i = stock.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [stock[i], stock[j]] = [stock[j], stock[i]];
                }
            }
            
            function dealCards() {
                for (let i = 0; i < 7; i++) {
                    for (let j = i; j < 7; j++) {
                        const card = stock.pop();
                        if (i === j) card.faceUp = true;
                        tableau[j].push(card);
                    }
                }
            }

            function createCardElement(card) {
                const cardEl = document.createElement('div');
                cardEl.id = card.id;
                cardEl.className = `card ${card.color}`;
                if (card.faceUp) cardEl.classList.add('face-up');
                cardEl.innerHTML = `
                    <div class="card-back"></div>
                    <div class="card-face">
                        <div class="card-top"><span class="card-rank">${card.rank}</span><span class="card-suit">${SUIT_SYMBOLS[card.suit]}</span></div>
                        <div class="card-middle-suit">${SUIT_SYMBOLS[card.suit]}</div>
                        <div class="card-bottom"><span class="card-rank">${card.rank}</span><span class="card-suit">${SUIT_SYMBOLS[card.suit]}</span></div>
                    </div>`;
                cardEl.addEventListener('mousedown', onDragStart);
                cardEl.addEventListener('touchstart', onDragStart, { passive: false });
                return cardEl;
            }

            function renderAllPiles() {
                renderStock();
                renderWaste();
                renderTableau();
                renderFoundations();
            }
            
            function renderStock() {
                stockEl.innerHTML = '';
                if (stock.length > 0) {
                    const cardBack = createCardElement({ id: 'stock-card', faceUp: false });
                    cardBack.style.position = 'static';
                    cardBack.removeEventListener('mousedown', onDragStart);
                    cardBack.removeEventListener('touchstart', onDragStart);
                    cardBack.addEventListener('click', drawFromStock);
                    stockEl.appendChild(cardBack);
                } else if (waste.length > 0) {
                    const recycleEl = document.createElement('div');
                    recycleEl.style.width = '100%';
                    recycleEl.style.height = '100%';
                    recycleEl.style.display = 'flex';
                    recycleEl.style.justifyContent = 'center';
                    recycleEl.style.alignItems = 'center';
                    recycleEl.style.fontSize = '3rem';
                    recycleEl.style.color = 'rgba(212, 175, 55, 0.5)';
                    recycleEl.style.cursor = 'pointer';
                    recycleEl.title = 'Reciclar Descarte';
                    recycleEl.innerHTML = '⟳';
                    recycleEl.addEventListener('click', drawFromStock);
                    stockEl.appendChild(recycleEl);
                }
            }
            
            function renderWaste() {
                wasteEl.innerHTML = '';
                if (waste.length > 0) {
                    const cardsToShow = (drawCount === 3) ? waste.slice(-3) : waste.slice(-1);
                    cardsToShow.forEach((card, index) => {
                         const cardEl = createCardElement(card);
                         if (index !== cardsToShow.length - 1) {
                            cardEl.removeEventListener('mousedown', onDragStart);
                            cardEl.removeEventListener('touchstart', onDragStart);
                            cardEl.style.cursor = 'default';
                         }
                         if(drawCount === 3) {
                           cardEl.style.left = `${index * 20}px`;
                           cardEl.style.top = '0';
                         }
                         wasteEl.appendChild(cardEl);
                    });
                }
            }

            function renderTableau() {
                tableauEls.forEach((pileEl, i) => {
                    pileEl.innerHTML = '';
                    tableau[i].forEach((card, j) => {
                        const cardEl = createCardElement(card);
                        cardEl.style.top = `${j * cardOffset}px`;
                        pileEl.appendChild(cardEl);
                    });
                });
            }

            function renderFoundations() {
                foundationEls.forEach((pileEl, i) => {
                    pileEl.innerHTML = '';
                    if (foundations[i].length > 0) {
                        const cardEl = createCardElement(foundations[i][foundations[i].length - 1]);
                        pileEl.appendChild(cardEl);
                    }
                });
            }
            
            function drawFromStock() {
                if (stock.length > 0) {
                    saveMoveState();
                    const cardsToDraw = Math.min(drawCount, stock.length);
                    for (let i = 0; i < cardsToDraw; i++) {
                        const card = stock.pop();
                        card.faceUp = true;
                        waste.push(card);
                    }
                } else if (waste.length > 0) {
                    saveMoveState();
                    updateScore(-100);
                    stock = [...waste].reverse();
                    stock.forEach(c => c.faceUp = false);
                    waste = [];
                }
                renderStock();
                renderWaste();
            }

            function onDragStart(e) {
                e.preventDefault();
                const cardEl = e.currentTarget;
                if (!cardEl.classList.contains('face-up')) return;
                const parentPileEl = cardEl.parentElement;

                dragState = { draggedCards: [], source: null, startMouseX: 0, startMouseY: 0, initialCardPositions: [] };

                let sourceCards = [];
                if (parentPileEl.classList.contains('tableau')) {
                    const pileIndex = parseInt(parentPileEl.id.split('-')[1]);
                    const cardIndex = tableau[pileIndex].findIndex(c => c.id === cardEl.id);
                    sourceCards = tableau[pileIndex].slice(cardIndex);
                    dragState.source = { type: 'tableau', pileIndex };
                } else if (parentPileEl.id === 'waste' && waste.length > 0) {
                    sourceCards = [waste[waste.length - 1]];
                    dragState.source = { type: 'waste' };
                } else if (parentPileEl.classList.contains('foundation')) {
                    const pileIndex = parseInt(parentPileEl.id.split('-')[1]);
                    if (foundations[pileIndex].length > 0) {
                        sourceCards = [foundations[pileIndex][foundations[pileIndex].length - 1]];
                        dragState.source = { type: 'foundation', pileIndex };
                    }
                } else {
                    return;
                }

                const touch = e.touches ? e.touches[0] : null;
                const clientX = touch ? touch.clientX : e.clientX;
                const clientY = touch ? touch.clientY : e.clientY;

                dragState.draggedCards = sourceCards;
                dragState.startMouseX = clientX;
                dragState.startMouseY = clientY;

                dragState.draggedCards.forEach((card) => {
                    const el = document.getElementById(card.id);
                    el.classList.add('dragging');
                    el.style.zIndex = 1000 + dragState.initialCardPositions.length;
                    dragState.initialCardPositions.push({
                        left: el.offsetLeft,
                        top: el.offsetTop
                    });
                });

                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('touchmove', onDragMove, { passive: false });
                document.addEventListener('mouseup', onDragEnd);
                document.addEventListener('touchend', onDragEnd);
            }

            function onDragMove(e) {
                if (e.type === 'touchmove') e.preventDefault();
                const touch = e.touches ? e.touches[0] : null;
                const clientX = touch ? touch.clientX : e.clientX;
                const clientY = touch ? touch.clientY : e.clientY;
                const deltaX = clientX - dragState.startMouseX;
                const deltaY = clientY - dragState.startMouseY;
                dragState.draggedCards.forEach((card, i) => {
                    const el = document.getElementById(card.id);
                    if (el) {
                        const initialPos = dragState.initialCardPositions[i];
                        el.style.left = `${initialPos.left + deltaX}px`;
                        el.style.top = `${initialPos.top + deltaY}px`;
                    }
                });
            }

            function onDragEnd(e) {
                document.removeEventListener('mousemove', onDragMove);
                document.removeEventListener('touchmove', onDragMove);
                document.removeEventListener('mouseup', onDragEnd);
                document.removeEventListener('touchend', onDragEnd);
                if (dragState.draggedCards.length === 0) return;
                const touch = e.changedTouches ? e.changedTouches[0] : null;
                const clientX = touch ? touch.clientX : e.clientX;
                const clientY = touch ? touch.clientY : e.clientY;
                const dropTarget = getDropTarget(clientX, clientY);
                let moveSuccessful = false;
                if (dropTarget) {
                    if (dropTarget.type === 'tableau' && isValidTableauMove(dragState.draggedCards[0], tableau[dropTarget.index])) {
                        performMove(dropTarget.type, dropTarget.index);
                        moveSuccessful = true;
                    } else if (dropTarget.type === 'foundation' && isValidFoundationMove(dragState.draggedCards[0], foundations[dropTarget.index], dropTarget.index)) {
                        performMove(dropTarget.type, dropTarget.index);
                        moveSuccessful = true;
                    }
                }
                if (!moveSuccessful) {
                    renderAllPiles();
                }
                dragState = { draggedCards: [], source: null, startMouseX: 0, startMouseY: 0, initialCardPositions: [] };
            }
            
            function getDropTarget(x, y) {
                for (let i = 0; i < 7; i++) {
                    const pile = tableau[i];
                    const rect = tableauEls[i].getBoundingClientRect();
                    const extendedRect = {
                        top: rect.top,
                        bottom: rect.bottom + (pile.length > 1 ? (pile.length - 1) * cardOffset : 0),
                        left: rect.left,
                        right: rect.right
                    };
                    if (y >= extendedRect.top && y <= extendedRect.bottom && x >= extendedRect.left && x <= extendedRect.right) {
                        return { type: 'tableau', index: i };
                    }
                }
                for (let i = 0; i < 4; i++) {
                    const rect = foundationEls[i].getBoundingClientRect();
                    if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) return { type: 'foundation', index: i };
                }
                return null;
            }

            function isValidTableauMove(card, targetPile) {
                if (targetPile.length === 0) return card.value === 13;
                const topCard = targetPile[targetPile.length - 1];
                return card.color !== topCard.color && card.value === topCard.value - 1;
            }
            
            function isValidFoundationMove(card, targetPile, targetIndex) {
                if (dragState.draggedCards.length > 1) return false;
                const foundationSuit = SUITS[targetIndex];
                if (card.suit !== foundationSuit) return false;
                if (targetPile.length === 0) return card.value === 1;
                const topCard = targetPile[targetPile.length - 1];
                return card.value === topCard.value + 1;
            }
            
            function performMove(targetType, targetIndex) {
                saveMoveState();
                
                // --- Scoring Logic ---
                let pointsEarned = 0;
                const sourceIsTableau = dragState.source.type === 'tableau';
                const sourceIsWaste = dragState.source.type === 'waste';
                const sourceIsFoundation = dragState.source.type === 'foundation';

                // Restriction: No points are awarded for any move originating from a foundation pile.
                if (!sourceIsFoundation) {
                    // Score for moving from Waste to Tableau
                    if (sourceIsWaste && targetType === 'tableau') {
                        pointsEarned = 25;
                    }
                    // Score for moving to a Foundation pile
                    else if (targetType === 'foundation') {
                        pointsEarned = 100;
                    }
                    // Score for moving from Tableau to Tableau
                    else if (sourceIsTableau && targetType === 'tableau') {
                        const sourcePile = tableau[dragState.source.pileIndex];
                        const cardsBeneathCount = sourcePile.length - dragState.draggedCards.length;
                        // Restriction: Points are only awarded if the move reveals a face-down card.
                        // This prevents gaining points by moving already revealed cards between columns.
                        if (cardsBeneathCount > 0 && !sourcePile[cardsBeneathCount - 1].faceUp) {
                            pointsEarned = 20;
                        }
                    }
                }

                if (pointsEarned > 0) {
                    updateScore(pointsEarned);
                }
                
                // --- Update Game State ---
                if (sourceIsTableau) {
                    const sourcePile = tableau[dragState.source.pileIndex];
                    sourcePile.splice(-dragState.draggedCards.length);
                    if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                        sourcePile[sourcePile.length - 1].faceUp = true;
                    }
                } else if (sourceIsWaste) {
                    waste.pop();
                } else if (sourceIsFoundation) {
                    foundations[dragState.source.pileIndex].pop();
                }

                if (targetType === 'tableau') {
                    tableau[targetIndex].push(...dragState.draggedCards);
                } else {
                    foundations[targetIndex].push(...dragState.draggedCards);
                }

                renderAllPiles();
                if (targetType === 'foundation') {
                    const cardEl = foundationEls[targetIndex].querySelector('.card');
                    if (cardEl) cardEl.classList.add('bounce');
                }
                checkWinCondition();
            }

            function saveMoveState() {
                moveHistory.push({
                    stock: JSON.parse(JSON.stringify(stock)),
                    waste: JSON.parse(JSON.stringify(waste)),
                    foundations: JSON.parse(JSON.stringify(foundations)),
                    tableau: JSON.parse(JSON.stringify(tableau)),
                    score: score
                });
                undoBtn.disabled = false;
            }
            
            function undoMove() {
                if (moveHistory.length === 0) return;
                const lastState = moveHistory.pop();
                stock = lastState.stock;
                waste = lastState.waste;
                foundations = lastState.foundations;
                tableau = lastState.tableau;
                score = lastState.score;
                updateScore(-2);
                renderAllPiles();
                if (moveHistory.length === 0) undoBtn.disabled = true;
            }

            function startTimer() {
                clearInterval(timerInterval);
                seconds = 0;
                timerEl.textContent = 'Tiempo: 00:00';
                timerInterval = setInterval(() => {
                    seconds++;
                    const min = String(Math.floor(seconds / 60)).padStart(2, '0');
                    const sec = String(seconds % 60).padStart(2, '0');
                    timerEl.textContent = `Tiempo: ${min}:${sec}`;
                }, 1000);
            }

            function checkWinCondition() {
                if (foundations.reduce((sum, pile) => sum + pile.length, 0) === 52) {
                    clearInterval(timerInterval);
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('solitaireHighScore', highScore.toString());
                    }
                    document.getElementById('final-score').textContent = score;
                    document.getElementById('high-score').textContent = highScore;
                    winMessageEl.classList.add('show');
                }
            }

            function showLoader() { loader.classList.add('show'); }
            function hideLoader() { loader.classList.remove('show'); }
            function showHint(text) { hintText.textContent = text; hintModal.classList.add('show'); }
            function hideHint() { hintModal.classList.remove('show'); }

            function formatGameStateForLLM() {
                let state = "Estado actual del juego de Solitario:\n";
                state += `Puntuación: ${score}\n`;
                state += `Tiempo: ${timerEl.textContent}\n`;
                
                const topWasteCard = waste.length > 0 ? `${waste[waste.length - 1].rank} de ${waste[waste.length - 1].suit}` : 'vacío';
                state += `Descarte: ${topWasteCard}\n`;
                
                state += "Bases:\n";
                foundations.forEach((pile, i) => {
                    const topCard = pile.length > 0 ? `${pile[pile.length - 1].rank} de ${SUITS[i]}` : 'vacío';
                    state += `- ${SUITS[i]}: ${topCard}\n`;
                });

                state += "Columnas:\n";
                tableau.forEach((pile, i) => {
                    if (pile.length === 0) {
                        state += `- Columna ${i+1}: vacía\n`;
                    } else {
                        const cardsStr = pile.map(c => c.faceUp ? `${c.rank} de ${c.suit}` : 'Boca abajo').join(', ');
                        state += `- Columna ${i+1}: ${cardsStr}\n`;
                    }
                });

                return state;
            }

            async function getHintFromLLM() {
                showLoader();
                getHintBtn.disabled = true;
                const systemPrompt = "Eres un experto en el juego de Solitario Klondike. Tu única función es analizar el estado actual del juego que se te proporciona y sugerir el mejor movimiento posible en una frase corta y directa. No saludes, no expliques las reglas, solo da la sugerencia. Si no hay movimientos posibles, dilo. Por ejemplo: 'Mueve el 5 de corazones sobre el 6 de picas.' o 'Voltea una carta del mazo.'";
                const userQuery = formatGameStateForLLM();
                const apiKey = ""; // API key is handled by the environment
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: userQuery }] }],
                            systemInstruction: { parts: [{ text: systemPrompt }] },
                        })
                    });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const result = await response.json();
                    const hint = result.candidates?.[0]?.content?.parts?.[0]?.text || "No se pudo obtener una pista.";
                    showHint(hint);
                } catch (error) {
                    console.error("Error fetching hint:", error);
                    showHint("Hubo un problema al contactar al experto en Solitario. Verifica tu conexión e inténtalo de nuevo.");
                } finally {
                    hideLoader();
                    getHintBtn.disabled = false;
                }
            }

            newGameBtn.addEventListener('click', initGame);
            winNewGameBtn.addEventListener('click', () => startGame(drawCount));
            undoBtn.addEventListener('click', undoMove);
            getHintBtn.addEventListener('click', getHintFromLLM);
            closeHintBtn.addEventListener('click', hideHint);
            easyModeBtn.addEventListener('click', () => startGame(1));
            realisticModeBtn.addEventListener('click', () => startGame(3));
            hintModal.addEventListener('click', (e) => { if (e.target === hintModal) hideHint(); });
            
            window.addEventListener('resize', () => {
                updateLayoutValues();
                renderTableau();
            });
            
            initGame();
            updateLayoutValues();
        });
    </script>
</body>
</html>
